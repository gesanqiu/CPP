# 内存

## 程序(进程)的内存布局

一般来讲，应用程序使用的内存空间有如下”默认“的区域：

- 栈：栈用于维护函数调用的上下文，局部变量和函数参数往往保存在其中，32为系统栈的大小最多为4MB，64为系统栈的大小最多为8MB，由高地址向低地址方向拓展。
- 堆：堆是用来容纳应用程序动态分配内存的区域，堆空间的申请与释放由程序员通过malloc/free和new/delete函数手动管理，由低地址向高地址方向拓展。
- 可执行文件映像：存储可执行文件在内存里的映像，由装载器在装载时将可执行文件的内存读取或映射到这里，根据读写属性进行基础的划分，主要包括代码段和数据段。
- 保留区：保留区并不是一个单一的内存区域，而是对内存中收到保护而禁止访问的内存区域的总称，例如中断向量表就存储在其中。

![programmer-memory_layout](images/programmer-memory_layout.png)

上图展示了32位系统和64位系统进程的程序布局。其中32位系统的寻址空间为4GB，最顶部1GB为kernel space，用户禁止访问，剩余空间为用户空间。64位系统理论寻址空间为`2^64`次方，但考虑到现实需求，目前仅使用了`2^48`寻址空间，其中kernel space占据顶部128TB，剩余128TB为用户空间。

## 栈与调用惯例

### 栈

在计算机系统中，栈是一个具有FIFO属性的动态内存区域，程序可以将数据压入栈中，也可以将数据从栈顶弹出。如前文所述，栈总是向下增长，栈顶则由esp（stack pointer）寄存器进行定位：压栈使得栈增大，即esp减小；出栈使得栈减小，即esp增大。**同样，直接减小esp的值也等效于在栈上开辟空间，直接增大esp的值等效于在栈上回收空间，即栈的大小变化在汇编层面上被反映为对esp寄存器值的修改(sub，add，mov，lea等命令)。**

栈保存了一个函数所需要的维护信息，通常被称作堆栈帧，在gdb中可以使用`i frame`查看当前调用函数堆栈的信息。堆栈帧一般包括如下几方面的信息：

- 函数的返回地址和参数。
- 临时变量：包括函数的非静态局部变量以及编译期自动生成的其他临时变量。
- 保存的上下文：包括在函数调用前后需要保持不变的寄存器。

通常，一个函数的活动记录用ebp（base pointere）和esp两个寄存器划定范围：esp始终指向栈的顶部，同时也就指向了当前函数的活动记录的顶部；ebp指向一个固定位置，一般是函数调用发生时esp的值，用于辅助函数内部数据寻址。一个典型的函数调用栈如下图所示：

![programmer-function_stack](images/programmer-function_stack.png)

之所以会形成这样的结构是由函数调用规则决定的：

- 把所有或一部分参数压入栈中，如果有其他参数没有入栈，那么使用某些特定的寄存器传递。
- 把当前指令的下一条指令的地址（返回地址）压入栈中。
- 跳转到函数体执行。

### 调用惯例

函数能够成功调用并返回的前提是函数的调用方和被调用方对函数如何调用有着统一的理解，这个统一的理解即是**调用惯例**，调用惯例通常包含以下内容：

- 函数参数的传递顺序和方式
- 栈的维护方式
- 名字修饰（name-mangling）策略

默认的调用惯例为`cdecl`：规定出栈放为函数调用方，参数以从右至左的顺序压入栈，名称修饰为下划线加函数名。还有其他的调用惯例，这里不做过多阐述。

## 堆