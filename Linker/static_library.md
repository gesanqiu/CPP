# 静态链接

```c
/* a.c */
extern int shared;

int main()
{
    int a = 100;
    swap(&a, &shared);
}

/* b.c */
int shared = 1;

void swap(int *a, int *b)
{
    *a ^= *b ^= *a ^= *b;
}
```

在熟悉了ELF文件格式之后，下一个问题是：当我们有多个目标文件时，如何将它们链接起来形成一个可执行文件。本章节将以上述两个C语言程序为例展开分析”静态链接”的过程。

## 空间与地址分配

对于链接器来说，整个链接过程中，它就是将几个输入目标文件加工后合并成一个输出文件。

### 按序叠加

最简单的方法就是将输入的目标文件按照次序叠加起来，但是在有很多输入文件的情况下，输出文件将会有很多零散的段，这种做法非常浪费空间，因为每个段都会有一定的地址和空间对其要求，会造成内存空间大量的内部碎片。

### 相似段合并

更实际的方法是将相同性质的段合并到一起：

- 空间与地址分配：扫描所有的输入目标文件，并且获得它们的各个段的产犊、属性和位置，并且将输入目标文件中的符号表中所有的符号定义和符号收集起来，统一放到一个**全局符号表**。在这一步中链接器能够获取所有输入目标文件的段长度，并且将他们合并，计算出输出文件中各个段合并后的长度与位置，并建立映射关系。
- 符号解析与重定位

- [ ] to-do：page 125/484，目标文件的各个段，objdump -h ，注意地址对齐

在链接之前，目标文件中的所有段的VMA都是0，因为虚拟空间还没有被分配，所以他们默认都为0。等到链接之后，可执行文件中的各个段都被分配到了相应的虚拟地址。

在Linux下，ELF可执行文件默认从地址0x08048000开始分配。

### 符号地址的确定

各个“段”的虚拟地址在上述第一步过程中就以确定，完成这一步之后链接器开始计算各个符号的虚拟地址——各个符号相对段的偏移量。

## 符号解析与重定位

### 重定位

通过objdump -d可以看到a.o的代码段反汇编结果:

```shell
# objdump -d a.o
```

让我们关注在a.c中引用了shared变量和swap函数，

- `C7 44 24 04 00 00 00 00`：mov指令总共8个字节，它的作用是将shared变量的地址赋值到ESP寄存器+4的偏移地址中去，但在编译阶段编译器并不知道shared和swap的地址，这时候shared变量的地址被假定为0x00000000
- `E8 FC FF FF FF`：call指令总共5个字节，0xE8是操作码，后四个字节是被调用函数相对于调用指令的下一条指令的偏移量，在没有重定位之前，相对便宜位置被置为0xFFFFFFFC（-4的补码）

```shell
# objdump -d ab
```

可以看到shared和地址为0x08049108，swap相对于下一条指令的偏址为0x00000009

### 重定位表

重定位表专门用来保存与重定位相关的信息

```shell
objdump -r a.o
```

每个要被重定位的地方叫一个重定位入口，重定位入口的偏移表示该入口在要被重定位的段中的位置。`.rela.text`表示这个重定位表是代码段的重定位表，0x1c和0x27代表shared和swap在代码段中的地址。

### 符号解析

重定位的过程中，每个重定位的入口都是对一个符号的引用，当链接器需要对某个符号的引用进行重定位时，链接器会去查找由所有输入目标文件的符号表组成的全局符号表，找到相应的符号后再进行重定位。

```shell
# readelf -s a.o
```

可以看到a.o中存在两个UND类型的符号，即shared和swap，假如链接器扫描完所有的输入目标文件之后，依然无法在全局符号表中找到这些UND类型的符号，就会报符号未定义错误。

### 指令修正方式

| x86基本重定位类型 |      |                   |
| ----------------- | ---- | ----------------- |
| 宏定义            | 值   | 重定位修正方法    |
| R_386_32          | 1    | 绝对寻址修正S+A   |
| R_386_PC32        | 2    | 相对寻址修正S+A-P |

- A=保存在修正位置的值
- P=被修正的位置（相对于段开始的偏移量或者虚拟地址）
- S=符号的实际地址

这里以a.o和ab为例：

- shared绝对寻址修正：S是shared符号的实际地址，即ab中的值0x08049108；A是被修正位置的值，即a.o中的值0x00000000。因此S+A=0x08049108。
- swap相对寻址修正：S是swap符号的实际地址，即ab中的值0x080480C8；A是a.o中的0xFFFFFFFC（-4）；P为被修正的地址，即swap指令的下一条指令的地址0x08048094+0x27。因此S+A-P=0x00000009。

绝对寻址修正和相对寻址修正的区别就是绝对寻址修正后的地址为该符号的实际地址；相对寻址修正后的地址为符号距离被修正位置的地址差。

## COMMON块

由于弱符号机制允许同一个符号的定义存在于多个文件中，而链接器本身并不支持符号的类型，因此当目标文件中多个弱符号定义类型不一致时，链接器便采用COMMON块的机制。

在SimpleSection.c中，编译器将未初始化的全局变量定义作为弱符号处理：

```shell
# readelf -s global_uninit_var
```

可以看到他是一个全局的数据对象，他的类型为SHN_COMMON类型。假如另外的目标文件中也定义了global_ubinit_car变量且未初始化，这个变量的类型为double，占8个字节，那么按照COMMON类型的连接机制，最终输出文件中的global_uninit_var变量为占8字节的double类型。

注：直接导致需要COMMON机制的原因是编译器和链接器允许不同类型的弱符号存在，但最本质的原因是链接器不支持符号类型。

Q：为什么不直接把未初始化的全局变量也当作未初始化的局部变量一样处理，为它在BSS段分配空间？

弱符号（例如未初始化的全局变量）在编译阶段无法确定它最终所占空间的大小，因为有可能其他编译单元中该符号所占的空间比本编译单元该符号所占的空间要大，因此编译器无法为其在BSS段分配空间，直到链接器在连接过程中最终确定了该符号的大小，再在最终输出文件的BSS段为其分配空间。

> 关于多个文件中出现同一个变量的多个定义的原因，还有一种说法是由于早期C语言程序员粗心大意，经常忘记在声明变量时在前面加上"extern"关键字，使得编译器会在多个目标文件中产生同一个变量的定义。为了解决这个问题，编译器和链接器干脆就把未初始化的变量都当作COMMON类型来处理。

注：GCC的"-fno-common"允许我们把所有未初始化的全局变量不以COMMON快的形式处理或者使用：

```c
int global __attribute__ ((nocommon));
```

经上述处理的未初始化的全局变量相当于强符号。

## C++相关问题

### 重复代码消除

C++编译器在很多时候会产生重复的代码，比如模板、外部内联函数和虚函数表都有可能在不同的编译单元里生成相同的代码。例如模板，当一个模板在多个编译单元同时实例化成相同的类型的时候，必然会生成重复的代码。假如将这些重复的代码都保存下来：

- 空间浪费
- 地址容易出错
- 指令运行效率较低，同一份指令有多份副本，指令Cache的命中率会降低

一个比较有效的而做法就是将每个模板的示例代码都单独地存放在一个段里，每个段只包含一个模板实例，这样当多个编译单元含有同样的模板函实例时，链接器在最终链接时可以将它们并入最后的代码段。

这种方法基本上能够解决代码重复的问题，但假如不同的编译单元使用了不同的编译器版本或者编译优化选项，导致同一个函数编译出来的实际代码有所不同，那么链接器将随意选择其中任意一个副本作为链接的输出，并输出

**函数级别链接**：当链接器需要用到某个函数时，就将它合并到输出文件中，对于那些没有用的函数则将他们抛弃。这么做能够减小输出文件的长度，减少空间浪费，但是会减慢编译和连接的过程，以及由于每个函数都需要存在单独的段中，目标文件会变大，重定位会变得复杂。GCC提供"-ffunction-sections"和"-fdata-sections"编译选项将每个函数或变量分别保持到独立的段中等待链接器处理。

### 全局构造与析构

ELF文件中还定义了两个段：

- .init：该段里面保存的时可执行指令，它构成了进程的初始化代码。因此，当一个程序开始运行时，在main函数被调用之前，Glibc的初始化部分安排执行这个段中的代码。
- .fini：该段保存着进程终止代码指令。因此，但一个程序的main函数正常退出时，Glibc会安排执行这个段中的代码。

C++的全局变量的构造和析构函数就保存在这两个段中。

### C++与ABI

一般的，将符号修饰标准、变量内存布局、函数调用方式等这些跟可执行代码二进制兼容性相关的内容成为ABI。

## 静态库链接

在编译时，一个源文件将被编译成一个目标文件，于是通常人们使用”ar“压缩程序将这些目标文件压缩到一起，并且对其进行行编号和索引，以便于查找和检索，因此一个静态库可以简单地看成一组目标文件的集合。

接下来以Hello，world！程序为例，演示printf()函数静态库的链接过程：

```shell
# objdump -t libc.a | grep printf

# ar -x libc.a

# ld hello.o printf.o

# gcc -static --verbose -fno-builtin hello.c

```

