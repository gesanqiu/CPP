# 链接的接口——符号

链接过程的本质就是要把多个不同的目标文件之间相互“粘”到一起，在链接中，目标文件之间相互拼合实际上是目标文件之间对地址的引用，即对函数和变量的地址的引用。

在链接中，每个函数和函数或变量都必须有自己独特的名字，才能避免链接过程中不同变量和函数之间的混淆。我们将函数和变量统称为符号，函数名或变量名就是符号名。每一个目标文件都会有一个相应的符号表，表中记录了目标文件中所有的符号及其对应的符号值，对于变量和函数来说符号值就是它们的地址。

目标文件的符号有很多种，但我们只关注其中的全局符号：

- 定义在本目标文件的全局符号：可以本其他目标文件引用，如func1。
- 被本目标文件引用的全局符号：外部符号，例如printf函数调用。

其他例如局部符号、段名、行号等符号都是次要的，因为它们仅本目标文件可见，连接过程中并不处理它们。

## 符号表的结构

符号表一般是ELF中的`.strtab`段，是一个`Elf64_Sym`结构的数组：

```c
typedef struct
{
  Elf64_Word    st_name;                /* Symbol name (string tbl index) */
  unsigned char st_info;                /* Symbol type and binding */
  unsigned char st_other;               /* Symbol visibility */
  Elf64_Section st_shndx;               /* Section index */
  Elf64_Addr    st_value;               /* Symbol value */
  Elf64_Xword   st_size;                /* Symbol size */
} Elf64_Sym;
```

| 成员名   | 含义                                                 |
| -------- | ---------------------------------------------------- |
| st_name  | 符号名，实际为该符号在字符串表中的offset             |
| st_info  | 符号类型和绑定信息                                   |
| st_other | 未使用的成员                                         |
| st_shndx | 符号所在的段的下标                                   |
| st_value | 符号相对应的值，与符号有关，可能是绝对值也可能是地址 |
| st_size  | 符号大小，对于包含数据的符号，为数据类型的大小       |

### 符号类型和绑定信息

st_info的低4为表示符号的类型，高28为表示符号绑定信息：

| 符号绑定信息 |      |                                    |
| ------------ | ---- | ---------------------------------- |
| 宏定义名     | 值   | 说明                               |
| STB_LOCAL    | 0    | 局部符号，对于目标文件的外部不可见 |
| STB_GLOBAL   | 1    | 全局符号，外部可见                 |
| STB_WEAK     | 2    | 弱引用                             |

| 符号类型    |      |                                                    |
| ----------- | ---- | -------------------------------------------------- |
| 宏定义名    | 值   | 说明                                               |
| STT_NOTYPE  | 0    | 未知类型符号                                       |
| STT_OBJECT  | 1    | 数据对象，如变量、数组等                           |
| STT_FUNC    | 2    | 函数或其他可执行代码                               |
| STT_SECTION | 3    | 段名符号，STB_LOCAL                                |
| STT_FILE    | 4    | 文件名，STB_LOCAL类型，st_shndx是SHN_ABS（绝对值） |

### 符号所在段

如果符号定义在本目标文件中，那么st_shndx表示符号所在的段在段表中的下标，除此以外还有特殊值：

| 符号绑定信息 |        |                                                              |
| ------------ | ------ | ------------------------------------------------------------ |
| 宏定义名     | 值     | 说明                                                         |
| SHN_ABS      | 0xfff1 | 表示该符号包含了一个绝对的值，比如表示文件名的符号就属于这种类型 |
| SHN_COMMON   | 0xfff2 | 表示 该符号是一个“COMMON”类型的符号                          |
| SHN_UNDEF    | 0      | 表示该符号未定义，这个符号表示该符号在本目标文件被引用到，但是定义在其他目标文件中 |

### 符号值

- 在目标文件中，如果是符号的定义并且该符号不是SHN_COMMON，则st_value表示该符号在段中的偏移
- 在目标文件中，如果是符号的定义并且该符号是SHN_COMMON，则st_value表示该符号的对齐属性
- 在可执行文件中，st_value表示符号的虚拟地址

```shell
ts@ts-OptiPlex-7070:~/Downloads/test$ readelf -s SimpleSection.o

Symbol table '.symtab' contains 16 entries:
   Num:    Value          Size Type    Bind   Vis      Ndx Name
     0: 0000000000000000     0 NOTYPE  LOCAL  DEFAULT  UND 
     1: 0000000000000000     0 FILE    LOCAL  DEFAULT  ABS SimpleSection.c
     2: 0000000000000000     0 SECTION LOCAL  DEFAULT    1 
     3: 0000000000000000     0 SECTION LOCAL  DEFAULT    3 
     4: 0000000000000000     0 SECTION LOCAL  DEFAULT    4 
     5: 0000000000000000     0 SECTION LOCAL  DEFAULT    5 
     6: 0000000000000004     4 OBJECT  LOCAL  DEFAULT    3 static_var.1840
     7: 0000000000000000     4 OBJECT  LOCAL  DEFAULT    4 static_var2.1841
     8: 0000000000000000     0 SECTION LOCAL  DEFAULT    7 
     9: 0000000000000000     0 SECTION LOCAL  DEFAULT    8 
    10: 0000000000000000     0 SECTION LOCAL  DEFAULT    6 
    11: 0000000000000000     4 OBJECT  GLOBAL DEFAULT    3 global_init_var
    12: 0000000000000004     4 OBJECT  GLOBAL DEFAULT  COM global_uninit_var
    13: 0000000000000000    34 FUNC    GLOBAL DEFAULT    1 func1
    14: 0000000000000000     0 NOTYPE  GLOBAL DEFAULT  UND printf
    15: 0000000000000022    49 FUNC    GLOBAL DEFAULT    1 main
```

readelf的输出格式与上面描述的Elf64_Sym的各个成员一一对应，除了第一个符号永远是一个未定义的符号其他的都是源码中定义符号。

以`static_var`为例，它是一个局部静态变量，大小为4，st_shndx为3，即位于`.data`段，st_value为4即它在`.data`段的offset为4，符合之前`objdump -s -d SimpleSection.o `中的输出情况。

### 符号修饰与函数签名

C语言的符号名与变量名和函数名一致，在含有大量库的情况下，不同目标文件之间的符号名将有可能发生冲突，

为了解决符号名冲突的问题，C++相继引入了命名空间和符号修饰机制。这两者的基础都是函数签名，符号修饰是具体的手段。函数签名包含了一个函数的所有信息：函数名、参数类型、所在的类和命名空间及其他信息，函数签名经过具体的符号修饰机制转换为符号名。

> GCC的基本C++名称修饰方法如下：所有的符号都以“_Z”开头，对于嵌套的名字（在命名空间或在类里面的），后面紧跟“N”，然后是各个名称空间和类的名字，每个名字前是名字字符串长度，再以“E”结尾。对于一个函数来说，它的参数列表紧跟在“E"后面。

返回值类型并不在修饰范围内，因此C++的函数重载不能是返回值重载。

可以使用c++filt工具解析修饰过的符号名。

注：除了函数，C++的全局变量和静态变量也有同样的机制。但对于全局变量来说，变量的类型并没有被加入到修饰后的名称中，所以无论这个变量是整形还是浮点型，甚至是一个全局对象，它的名称都是一样的，即变量再某个作用域中一定是唯一的。

注：不同的编译器采用不同的名字修饰方法，必然会导致有不同编译器编译产生的目标文件无法正常相互连接， 这也是目标文件无法跨平台使用的主要原因。

### extern ”C“

C++为了与C兼容，在符号的管理上，C++有一个用来声明或定义一个C的符号的`extern "C"`关键字用法，C++编译器会将在`extern "C"`内部的代码当作C语言代码处理，即C++的符号修饰机制将不会生效。

### 弱符号与强符号

多个目标文件中含有相同名字全局符号的定义，那么这些目标文件链接的时候将会出现符号重复定义的错误。对于C/C++语言来说，编译器默认函数和初始化了的全局变量为强符号，未初始化的全局变量为弱符号。但是也可以通过GCC的`__attribute__((weak))`来定义任何一个强符号为弱符号。

针对强弱符号的概念，链接会按如下规则处理与选择被多次定义的全局符号：

- 不允许强符号被多次定义
- 如果一个符号在某个目标文件中是强符号，在其他文件中都是若符号，那么选择强符号
- 如果一个符号在所有目标文件中都是弱符号，那么选择其中占用空间最大的一个

与强弱符号对应的是强弱引用，链接器在将目标文件链接成可执行文件时对于未找到的强引用将报符号未定义错误，但是对于弱引用则不报错误，等待运行时再抛出非法地址访问的错误。

> 弱符号与弱引用对于库来说十分有用，比如库中定义的弱符号可以被用户定义的强符号所覆盖，从而使得程序可以使用自定义版本的库函数。或者程序可以对某些扩展功能模块的引用定义为弱引用，当我们将扩展模块与程序链接在一起时，功能模块就可以正常使用；如果我们去掉了某些功能模块，那么程序也可以正常链接，只是缺少了相应的功能，这使得程序的功能更加容易裁剪和组合。

