# 动态链接

## 为什么要动态链接

- 内存和磁盘空间：在静态链接的情况下，假设多个程序都链接到同一个静态目标对象（C语言标准库等），那么当这些程序同时运行时，所有的进程都会将这个静态目标文件加载到内存中，也就是内存中存在多个同一静态目标文件的副本，造成大量的空间浪费。
- 程序的开发和发布：假如使用静态链接，那么当静态库发生更新时，所有连接到这个静态库的程序都需要重新编译和链接。
- 动态链接：基本思想就是“直到程序运行时才对那些组成程序的目标文件进行链接”，这样做的好处就是内存中只会装在一个动态库，所有依赖于这个库的程序都共享同一个目标文件。这样做不仅可以节省内存，还可以减少物理页面的置换，提高CPU缓存的命中率；同时在发布新版本时只需要覆盖掉想要更新的模块即可。
- 程序的可拓展性和兼容性：程序的发布和版本管理，这里不做详细讨论。

## 简单的动态链接例子

to-do：complile sample

### lib.so参与链接

当链接器将program1.o链接成可执行文件时，必须确定foobar()的性质。如果foobar是一个定义于其他静态目标文件中的函数，那么链接器会按照静态链接的规则，将program1.o中的foobar地址引用重定位；如果foobar是定义在动态共享对象中的函数，那么链接器会将这个符号引用标记为一个动态连接符号，直到装载这个动态共享对象时再进行重定位。为了确认foobar函数的性质，有必要将foobar所处的静态目标文件或动态共享对象作为链接的输入文件之一，这样链接器才能对foobar的引用做特殊处理，使它成为一个对动态符号的引用。

### 动态链接程序运行时地址空间分布

to-do：cat  /proc/p-id/maps

动态链接器与普通共享对象一样被映射到了进程的地址空间，在系统开始运行program1之前，首先会把控制权交给动态链接器，由它完成所有的动态链接工作以后再把控制权交给program1，然后开始执行。

to-do：readelf -l lib.so

共享对象的最终装载地址在编译时是不确定的，而是在装载时，装载器根据当前地址的空闲情况，动态分配一块足够大小的虚拟地址空间给相应的共享对象。

## 地址无关代码

- 装载时重定位：在链接时，对所有绝对地址的引用不作重定位，而把这一步推迟到装载时再完成。一旦模块装载地址确定，即目标地址确定，那么系统就对程序中所有的绝对地址引用进行重定位。

动态链接模块被装载映射至虚拟空间后，指令部分是在多个进程之间共享的，但是由于装载时重定位的方法需要修改指令（每个进程的绝对地址都不一样，不同进程重定位后的绝对地址都不一样），所以没有办法做到同一份指令被多个进程共享，为了能够实现程序模块中共享的指令部分在装载时不需要因为装载地址的改变而改变，提出了地址无关代码技术。

### 模块内部调用或跳转

模块内部的跳转、函数调用都可以是相对地址调用或者是基于寄存器的相对调用，所以对于这种指令是不需要重定位的。

### 模块内部数据访问

对于编译后的模块（目标文件）来说，任何一条指令与它需要访问的模块内部数据之间的相对位置是固定的，那么只需要相对于当前指令加上固定的偏移量就可以访问模块内部数据了。

to-do：de-assembly codes

函数的作用能够将返回地址的值放到ecx寄存器中，即call的下一条指令的地址放到ecx寄存器。

根据反汇编代码，可以看到a的地址是add指令地址加上0x118c和0x28。

### 模块间数据访问

要使得代码地址无关，基本的思想就是把跟地址相关的部分放到数据段里面，所以很明显其他模块的全局变量的地址是跟模块装载地址有关的。ELF会在数据段里面建立一个指向这些变量的指针数组，称为全局偏移表。当代码需要引用该全局变量时，可以通过GOT中相对应的项间接引用。

当指令需要访问变量b时，程序会先找到GOT，然后根据GOT中变量所对应的项找到变量的目标地址：链接器在装载模块的时候会查找每个变量所在的地址，然后填充GOT中的各个项，以确保每个指针所指向的地址正确。根据反汇编代码，变量b的地址在.so文件中的偏址为ecx寄存器地址0x454+0x118c-8=0x15d8，其中0x454+0x118c=0x15d0为GOT的地址，-8为变量b在GOT中的偏移。

to-do: objdump -h pic.so | grep got

to-do: objdump -R pic.so

### 模块间调用或跳转

模块间调用和跳转与模块间数据访问类似，同样是将函数地址存在GOT中间接寻址。

### 共享模块的全局变量问题

```c++
# module.c
extern int global;
int foo()
{
    global = 1;
}
```

如上述代码，假设一个模块引用了一个定义在共享对象的全局变量，当编译器编译module.c时，它无法根据这个上下文判断global是定义在同一个模块的其他目标文件还是定义在另外一个共享对象之中，即无法判断是否为跨模块间调用。

假设module.c时程序可执行文件的一部分，那么在这种情况下，由于程序的主模块代码并不是地址无关代码，变量global的地址必须在链接的时候确定下来，按照之前的讲述，链接器会程序在.bss段中创建一个global变量的副本。那么当global变量定义在某一个被程序引用的共享对象时，将发生冲突。

为了解决这个问题，ELF共享库在编译时，默认把定义在模块内部得全局变量当作定义在其他模块得全局变量，通过GOT来实现变量得访问，当共享模块被加载时：

- 如果某个全局变量在可执行文件中拥有副本，那么动态链接器就会把GOT中得相应地址指向该副本。
- 如果变量在共享模块中被初始化，那么动态链接器还需要将该初始化值复制到程序主模块中的变量副本。
- 如果该全局变量在程序主模块中没有副本，那么GOT中的相应地址就指向模块内部的副本。

### 数据段数据段地址无关性

```c++
static int a;
static int* p = &a;
```

上述代码假如出自某个共享对象，那么指针p的地址将是一个绝对地址，它指向变量a，而变量a的地址会随着共享对象的装在地址改变而改变。

为了保证数据段地址的无关性，可以使用间接寻址的方式，但是对于数据段来说，它在每个进程都有一份独立的副本，所以不用担心它被进程改变，于是可以使用装载时重定位的方法来解决数据段中绝对地址引用问题。

## 延迟绑定

在动态链接下，程序模块之间包含了大量的函数引用，在程序开始执行之前，动态链接会耗费不少时间用于解决模块之间的函数引用的符号查找一级重定位。为了提高执行效率，ELF采用了延迟绑定的技术，当函数第一次被用到是才进行绑定。延迟绑定基于PLT的方法实现，PLT在通过GOT跳转的过程中增加了一层间接跳转判断。

## 动态链接相关结构

### .interp段

在Linux中，操作系统在对可执行文件进行加载的时候，它会区寻找装载该可执行文件所需要相应的动态链接器，这个动态链接器的地址保存在`.interp`段中。

### .dynamic段

`.dynamic`段中保存了动态链接器所需要的基本信息，比如依赖于哪些共享对象、动态链接符号表的位置、动态链接重定位表的位置、共享对象初始化代码的地址等。

### 动态符号表

保存与动态链接相关的符号，对于那些付块内部的符号，比如模块私有变量则不保存。很多时候动态链接的模块同时拥有`.dynsym`和`.symtab`两个表，.symtab中往往保存了所有符号，包括/dynsym中的符号。

### 动态链接重定位表

无论是可执行文件或共享对象，一旦它依赖于其他共享对象，也就是说有导入的符号时，那么它的代码或数据中就会还有对于导入符号的引用。在编译时这些导入符号的地址未知，在静态链接中，这些未知的地址引用在最终链接时被修正。但是在动态链接中，导入符号的地址在运行时才确定，所以需要在运行时将这些导入符号的引用修正。

### 动态链接是进程堆栈初始化信息